### Riverpod VS Provider

- 同一个作者，Riverpod 就是对 Provider 的重写；
- Riverpod 不依赖 BuildContext， 但 Provider 是 InheritedWidget 的封装，所以在读取状态时需要 BuildContext；
- 对 Provider 来说，provider 是 widget，对于 Riverpod 来说， provider 不是 widget 而是普通的 Dart 对象；
- 在 Riverpod 中 ConsumerWidget/ConsumerStatefulWidget 类，而不是 StatelessWidget/StatefulWidget 类；

### 安装的软件包

```
dependencies:
  flutter:
    sdk: flutter
  flutter_riverpod: ^2.1.3
  riverpod_annotation: ^1.1.1
dev_dependencies:
  flutter_test:
    sdk: flutter
  build_runner:
  riverpod_generator: ^1.1.1
```

### 添加插件

- VS Code，下载 Flutter Riverpod Snippets

### 创建简单的 provider

```
顶级添加ProviderScope，用来储存各个 provider
void main() {
  runApp(const ProviderScope(child: MyApp()));
}

```

- provider 文件中创建

```
 - model
 - stateNotifier
 - createProvider
 - computed
```

- 创建 state 数据 model, 当前为 Todo
- 创建一个 StateNotifier

```
state 返回一个List<Todo> 可根据实际数据格式创建model

class TodosNotifier extends StateNotifier<List<Todo>> {
  TodosNotifier() : super([]);
  @override
  List<Todo> build() {
    return [];
  }
  addTodo(String title) {
  }
  removeTodo(String id) {
  }
  completedToggle(String id) {
  }
}

```

- 创建 provider

```
final todosProvider =
    StateNotifierProvider<TodosNotifier, List<Todo>>((ref) => TodosNotifier());
```

- 获取一些计算

```
@riverpod
List<Todo> getCompletedTodos(WidgetRef ref) {
  final List<Todo> todos = ref.watch(todosProvider);
  return todos.where((todo) => todo.isCompleted).toList();
}

```

- 使用 provider

  - ConsumerWidget

  ```
  // build第二个参数为ref
  Widget build(BuildContext context, WidgetRef ref)
  监听数据
  ref.watch(todosProvider)
  获取方法
  ref.read(todosProvider.notifier)
  ```

  - ConsumerStatefulWidget

  ```
  全局的ref, 可以直接通过ref获取数据或操作
  监听数据
  ref.watch(todosProvider)
  获取方法
  ref.read(todosProvider.notifier)
  ```

- 使用 Provider 缓存计算
  - 使用 ConsumerStatefulWidget 或者 ConsumerWidget，在 build 都会造成 render

```
  // 第一版
  // 直接使用 ConsumerWidget, state的改变会造成的build重新render
  TextButton(
    onPressed: ref.watch(pageButtonNotifierProvider) > 0
      ? ref.read(pageButtonNotifierProvider.notifier).pre
      : null,
    child: const Text('上一页')
  )
```

```
  // 第二版
  // 使用普通widget， 组件局部Consumer精准更新
  Consumer(builder: (context, ref, child) {
    final onPressed = ref.watch(pageButtonNotifierProvider) > 0
      ? ref.read(pageButtonNotifierProvider.notifier).pre
      : null;
    return TextButton(onPressed: onPressed, child: const Text('上一页'));
  }),
```

```
  // 第三版
  // 根据已有pageButtonNotifierProvider，创建新的Provider，缓存数据
  canGoToPreviousPageProvider = Provider<bool>((ref) {
      return ref.watch(pageButtonNotifierProvider) > 0;
    });
  // 使用时canGoToPreviousPageProvider变化才会从新render
  Consumer(builder: (context, ref, child) {
    final onPressed = ref.watch(canGoToPreviousPageProvider)
      ? ref.read(pageButtonNotifierProvider.notifier).pre
      : null;
    return TextButton(onPressed: onPressed, child: const Text('上一页'));
  })
```
